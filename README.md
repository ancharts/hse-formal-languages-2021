# HW04

## Дедлайн: 23:59 04.10

0. Актуализировать свое описание языка описаний конечных автоматов: оно должно быть самостоятельным и максимально подробным. Это должно быть описание того языка, которое вы будете парсить в последнем задании. Если вы внезапно поняли, что не знаете, как парсить ваш язык и вам нужно внести в него исправления, напишите хотя бы об этом, чтобы коллеги не делали лишнюю работу.

### Описание языка:

   * В первой строке входного файла описан алфавит, каждый символ закодирован в виде 8-битного кода (ASCII), символы разделены пробелами.
   * Во второй строке через пробел перечислены состояния в формате номер (любое неотрицательное число) и (без пробела) тип:
       *  'S' для стартового 
       *  'M' для промежуточного
       *  'T' для конечного.
   * Далее идет описание переходов по одному в каждой строке, формат: состояние, дефис, состояние, пробел, далее через пробел символы алфавита, по которым осуществляется переход.
   * Последняя строка обязательно завершается переводом строки :)

* Пример:

```
01000001 0100001001000010 010000010100000101000001 01000001
0S 1M 1T 2M
0S-1M 01000010 01000001 0100000101000001
1M-0S 0100000101000001
1M-1T 01000010 01000001
1T-1M 0100001001000001 01000001
1T-2M 010000010100000101000001
2M-1T 0100001001000001
2M-0S 010000010100000101000001
0S-2M 0100000101000001

```

1. Изучить язык для описания конечных автоматов двух ваших коллег (тех, кто непосредственно перед и после вас в списке группы). Описать несколько автоматов на этих языках, а также придумать несколько некорректных входных файлов, приложить их к отчету. Написать обратную связь, оценив следующие особенности. (2 балла)

   * Насколько язык хорошо описан.
   * Насколько язык сам по себе удобен.
   * Если есть поддержка в среде разработки, то насколько она удобная.
   * Насколько понятные сообщения об ошибках выдает синтаксический анализатор.
   * Постараться найти ошибки: неточности описания, несоответствие работы синтаксического анализатора описанию языка, неправильные результаты

### Мартюшев

Язык описан подробно, на мой взгляд, было бы хорошо добавить еще пример в тот же файл, чтобы можно было понимать, как это должно выглядеть.

Язык удобен для парсинга -- везде указано количество состояний, переходов и т.д., т.е. понятно, сколько строк нужно считать и распарсить как переход или состояние.

С другой стороны, по той же причине язык не очень удобен в использовании -- когда мы описываем автомат, мы не всегда сходу знаем, сколько состояний и переходов потребуется.

Не хватает возможности использовать в качестве символов алфавита пробел и перенос строки, предложения: 
* использовать 8-битный код
* просить пользователя вводить символы алфавита по одному в строке, тогда можно считывать строку условным `getline()` и, если переносы строки будут записаны как `\n`, а не как настоящий перенос строки, все должно работать

#### Тесты:

##### 1. 
* проверка возможности использовать другие символы типа `char` кроме букв и цифр, которую гарантирует язык
* конечный полный детерминированный автомат, все символы и состояния которого уникальны, есть ровно одно стартовое состояние

```
2
a#a#a b$b
3 
start q1 
terminal q3
q2
6
q1 q3
a#a#a
q1 q2 
b$b
q2 q3
a#a#a
q2 q2
b$b
q3 q3
a#a#a
q3 q3
b$b
```

##### 2.
* автомат, в котором нет стартового состояния
* недетерминированный автомат
* неполный автомат

```
3
a#a#a b$b 4r4
3 
q1 
terminal q3
q2
4
q1 q2 
b$b
q1 q3
b$b
q2 q3
a#a#a
q2 q2
b$b
```

##### 3.
* автомат, в котором символы алфавита не уникальны
* автомат, в котором 2 стартовых состояния
* автомат, в котором состояния не уникальны
* неполный автомат

```
3
a#a#a b$b b$b
4 
start q1 
start q2
terminal q3
q2
4
q1 q2 
b$b
q1 q3
b$b
q2 q3
a#a#a
q2 q2
b$b
```

2. Реализовать синтаксический анализатор для вашего языка описания конечных автоматов. (4 балла)

   * Можно писать на любом языке.
   * Можно использовать любой способ писать парсеры (дефолтный вариант -- генераторы синтаксических анализаторов семейства yacc).
   * Задание должно быть оформлено как консольное приложение, принимающее как аргумент командной строки путь ко входному файлу. Результат синтаксического анализа должен быть записан в файл с тем же именем, но добавочным расширением `.out` (если вход -- `input.txt`, то результат работы записать в `input.txt.out`).
   * Результатом синтаксического анализа должно быть некоторое представление конечного автомата в виде структуры данных, принятой в выбранном вами языке программирования (структура, класс, что-то другое, специфицирующее автомат как множество состояний (+ какое из них стартовые, а какие -- конечные), алфавит и переходы). В файл с результатом надо будет красиво напечатать результат анализа.
   * Если вход некорректен, сообщить об ошибке цивилизованно: исключениями в пользователя бросать не стоит.
   * Обязательно привести тесты для вашего парсера.

Реализован в `parse.py`, файлы с тестами: `test.dfa`, `test2.dfa`, ожидаемый вывод в `test.dfa.out` и `test2.dfa.out`.
Запускается командой `python parse.py название_входного_файла`, например, `python parse.py test.dfa`.


3. Добавить функции, проверяющие корректность автомата после успешного синтаксического анализа (2 балла).

   * Результат должен печататься в тот же файл, куда печатается результат синтаксического анализа.

   * Проверять стоит следующие вещи:

      * У автомата есть начальное состояние. +
      * Состояния автомата уникальны. +
      * Символы алфавита уникальны. +
      * Конечный автомат детерминирован. +
      * Конечный автомат полон. +
      * Еще какие-то проверки, которые вы посчитаете интересными. + (проверяет, одно начальное состояние у автомата или больше)

   * Дополнить тесты, чтобы они тестировали корректность этих проверок.

